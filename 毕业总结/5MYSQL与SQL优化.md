# 5MYSQL与SQL优化

## 1、什么是性能

### 必知必会

- 吞吐量与延迟

	- 有些结论是反直觉的，指导我们关注什么

- 必须有监控

	- 没有量化就没有改进：监控与度量指标，指导我们怎么去入手

- 80/20原则

	- 先优化性能瓶颈问题，指导我们如何去优化

- 过早的优化是万恶之源

	- 指导我们要选择优化的时机

- 脱离场景谈性能都是耍流氓

	- 指导我们对性能要求要符合实际

### DB/SQL优化是业务系统性能优化的核心

- 业务系统分类

	- 计算密集型
	- 数据密集型

- DB/SQL操作的消耗在一次业务处理中占比最大

## 2、关系数据库与MySQL

### 什么是关系数据库

- 起源

	- 1970，关系模型，关系代数理论作为数学基础

- 描述

	- E-R图

- 设计原则

	- 1NF

		- 表中同一列中不能有多个值，原子性

	- 2NF

		- 表每个行能被唯一区分

	- 3NF

		- 消除传递依赖，消除表中列不依赖主键，而是依赖表中的非主键列的情况，即没 有列是与主键不相关的

	- BCNF

		- 3NF 的基础上消除主属性对于码的部分与传递函数依赖

	- 4NF

		- 消除非平凡的多值依赖

	- 5NF

		- 消除一些不合适的连接依赖

- 常见数据库

	- 关系数据库

		- 开源

			- MySQL
			- PostgreSQL

		- 商业

			- Oracle
			- DB2
			- SQL Server

	- 其他

		- 内存数据库：Redis？，VoltDB 
		- 图数据库：Neo4j，Nebula 
		- 时序数据库：InfluxDB、openTSDB 
		- 其他关系数据库：Access、Sqlite、H2、Derby、Sybase、Infomix等 
		- NoSQL数据库：MongoDB、Hbase、Cassandra、CouchDB 
		- NewSQL/分布式数据库：TiDB、CockroachDB、NuoDB、OpenGauss、OB、TDSQL

### SQL

- 分类

	- DQL
	- DML
	- TCL
	- DCL
	- DDL
	- CCL

### MySQL

- 发展

	- 目前分裂为：MariaDB, MySQL

- 版本

	- - 4.0支持InnoDB，事务 
	- - 2003年，5.0 
	- - 5.6 ==> 历史使用最多的版本 
	- - 5.7 ==> 近期使用最多的版本 
	- - 8.0 ==>最新和功能完善的版本

- 不同版本的差异

	- 5.6/5.7的差异

		- 5.7支持

			- 多主一从
			- MGR

				- MySQL Group Replication:MySQL官方推出的一种基于Paxos协议的状态机复制
				- 保证数据一致性

					- 异步复制（异步relay log、不确保是否relay log写成功）、半同步复制（写完relay才ACK）无法保证数据的一致性
					- 一个事务的提交，必须经过组内大多数节点（N / 2 + 1）决议并通过，才能得以提交。

				- https://www.cnblogs.com/luoahong/articles/8043035.html

			- 分区表
			- 支持json格式
			- 性能提升
			- 改进XA

				- https://blog.csdn.net/peterwanghao/article/details/100734037

	- 5.7/8.0的差异

		- 8支持

			- 通用表表达式

				- 

			- 窗口函数
			- 持久化参数

				-  SET PERSIST 命令

			- 自增列持久化
			- 默认编码utf8mb4

				- 包含所有emoji

			- DDL原子性
			- JSON增强
			- 不再对group by进行隐式排序

				- 坑！！！

		- 参考资料

			- https://blog.csdn.net/u011334954/article/details/108240173
			- https://www.cnblogs.com/gaogao67/p/10392764.html
			- https://www.cnblogs.com/cchust/p/11099450.html

## 3、mysql数据库原理

### mysql

- 架构图

	- 

- 数据存储

	- 独占模式

		- 1）、日志组文件：ib_logfile0和ib_logfile1，默认均为5M
		- 2）、表结构文件：*.frm 
		- 3）、独占表空间文件：*.ibd 
		- 4）、字符集和排序规则文件：db.opt 
		- 5）、binlog二进制日志文件：记录主数据库服务器的DDL和DML操作 
		- 6）、二进制日志索引文件：master-bin.index

	- 共享模式
innodb_file_per_table=1

		- 数据都在ibdata1

- 执行流程

	- 简化

		- 

	- 详细

		- 

- 执行引擎

	- 

- SQL执行顺序

	- 

- 索引原理

	- 数据结构

		- B+树
		- 备注：也有采用B树的数据库
		- 没有所谓B-树，这个是误传！

	- InnoDB索引分类

		- 聚簇索引/主键索引

			- 非叶子节点存主键，
叶子节点存实际数据

		- 非聚簇索引

			- 非叶子节点存索引，
叶子节点存主键

	- 注意

		- 不同存储引擎对索引实现方式不同！
		- 上面说的是InnoDB
		- https://blog.csdn.net/qq_35956041/article/details/81017995
		- MyISAM索引实现

			- MyISAM的B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的。这里的索引都是非聚簇索引。
			- MyISAM还采用压缩机制存储索引，比如，第一个索引为“her”，第二个索引为“here”，那么第二个索引会被存储为“3,e”，这样的缺点是同一个节点中的索引只能采用顺序查找。

	- 为何一般单表数据不能超过2kw？

		-  MySQL 常用的 InnoDB 引擎（支持事务，有行级锁），使用的 B+树的索引结 构，同时用固定大小的页来存储，数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？
		- 假设一行数据的大小是 1k，那么一个页（innodbpagesize 一般为 16k）可以存放 16 行这样的数据。InnoDB 存储引擎的最小存储单元是页，页可以用于存放数据也可以用于存放键值 + 指针，在 B+ 树中叶子节点存放数据，非叶子节点存放键值 + 指针。索引组织表通过非叶子节点的二分查找法以及指针确定数据在哪个页中，进而在去数据页 中查找到需要的数据。为了跟磁盘 io 的交互次数 2-3 次就能找到一条记录，我们假设树不超过 3 层。
		- 我们假设主键 ID 为 bigint 类型，长度为 8 字节，而指针大小在 InnoDB 源码中设置 为 6 字节，这样一共 14 字节，我们一个页中能存放多少这样的单元，其实就代表有多少指针，即 16384/14=1170。
		- 那么可以算出一棵高度为 2 的 B+ 树，能存放 1170*16=18720 条这样的数据记录。
		- 根据同样的原理我们可以算出一个高度为 3 的 B+ 树可以存放：1170 x 1170 x 16=21902400 （两千万）条这样的记录。

## 4、mysql配置优化

### 连接请求的变量

- 1、max_connections 
- 2、back_log 
- 3、wait_timeout和interative_timeout

### 缓冲区变量

- 4、key_buffer_size 
- 5、query_cache_size（查询缓存简称QC) 
- 6、max_connect_errors： 
- 7、sort_buffer_size： 
- 8、max_allowed_packet=32M 
- 9、join_buffer_size=2M 
- 10、thread_cache_size=300

### 配置Innodb的几个变量

- 11、innodb_buffer_pool_size 
- 12、innodb_flush_log_at_trx_commit 
- 13、innodb_thread_concurrency=0 
- 14、innodb_log_buffer_size 
- 15、innodb_log_file_size=50M 
- 16、innodb_log_files_in_group=3 
- 17、read_buffer_size=1M 
- 18、read_rnd_buffer_size=16M 
- 19、bulk_insert_buffer_size=64M 
- 20、binary log

### 查看参数配置

- show variables like xxx
- my.cnf文件

## 5、数据库设计-最佳实践

### - 如何恰当选择引擎？ 

### - 库表如何命名？ 

### - 如何合理拆分宽表？ 

### - 如何选择恰当数据类型：明确、尽量小 

###     - char、varchar的选择 

###     - （text/blob/clob）的使用问题？ 

###     - 文件、图片是否要存入到数据库？ 

###     - 时间日期的存储问题？

###     - 数值的精度问题？ 

### - 是否使用外键、触发器？

### - 唯一约束和索引的关系？ 

### - 是否可以冗余字段？ 

### - 是否使用游标、变量、视图、自定义函数、存储过程？ 

### - 自增主键的使用问题？ 

### - 能够在线修改表结构（DDL操作）？ 

### - 逻辑删除还是物理删除？ 

### - 要不要加create_time,update_time时间戳？ 

### - 数据库碎片问题？ 

### - 如何快速导入导出、备份数据？

## 6、mysql事务与锁

### 基础

- ACID

	- Atomicity原子性
	- Consistency一致性

		- 跨表、跨行、跨事务, 数据库始终保持一致状态

	- Isolation隔离性

		- 隔离性, 可见性, 保护事务不会互相干扰, 包含4种隔离级别

	- Durability持久性

		- 事务提交成功后,不会丢数据。如电源故障, 系统崩溃

- mysql4.0引入InnoDB,以支持事务

	- 双写缓冲区、故障恢复、操作系统、fsync() 、磁盘存储、缓存、UPS、网络、备份策略 ……

- mysql锁

	- 表级锁

		- 上锁前需要先上意向锁
		- 意向锁：表明事务稍后要进行哪种类型的锁定

			- 
			- 共享意向锁(IS): 打算在某些行上设置共享锁
			- 排他意向锁(IX): 打算对某些行设置排他锁

				- select for update

			- Insert意向锁: Insert操作设置的间隙锁

		- 其他

			- 自增锁AUTO-IN
			- LOCK TABLES:执行DDL时，mysqldump时

	- 行级锁（InnoDB）

		- 记录锁(Record): 始终锁定索引记录，注意隐藏的聚簇索引; 
		- 间隙锁(Gap): 操作范围
		- 临键锁(Next-Key): 记录锁+间隙锁的组合; 可“锁定”表中不存在记录 
		- 谓词锁(Predicat): 空间索引

	- 死锁

		- 阻塞与互相等待
		- 增删改、锁定读
		- 死锁检测与自动回滚
		- 锁粒度与程序设计
		- 高并发下如何尽量避免死锁

			- sql尽量简单

				- sql复杂的情况

					- 连了很多表，10+
					- 条件复杂，20多个条件

			- 不要有跨很多行的操作，尽量针对某些id进行操作，而不是范围

### 隔离级别

- 定义

	- 读未提交: READ UNCOMMITTED

		- 一个事务还没提交时，它做的变更就能被别的事务看到。
		- 很少使用
		- 问题

			- 不能保证一致性
			- 脏读(dirty read) : 使用到从未被确认的数据(例如: 早期版本、回滚)

		- 锁

			- 以非锁定方式执行
			- 可能的问题: 脏读、幻读、不可重复读

	- 读已提交: READ COMMITTED

		- 一个事务提交之后，它做的变更才会被其他事务看到。
		- 每次查询都会设置和读取自己的新快照
		- 仅支持基于行的bin-log
		- UPDATE优化: 半一致读(semi-consistent read)

			- mysql高版本已去掉，不太好

		- 不可重复读: 不加锁的情况下, 其他事务UPDATE或 DELETE会对查询结果有影响
		- 幻读(Phantom): 加锁后, 不锁定间隙, 其他事务可以INSERT
		- 锁

			- •锁定索引记录, 而不锁定记录之间的间隙
			- 可能的问题: 幻读、不可重复读

	- 可重复读: REPEATABLE READ

		- 一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
		- InnoDB的默认隔离级别

			- 其他一般是RC读已提交
			- 历史遗留导致

		- 使用事务第一次读取时创建的快照
		- 多版本技术

			- MVCC
			- 目前主流数据库依赖于多版本的思想

		- 锁

			- 使用唯一索引的唯一查询条件时, 只锁定查找到的索引记录, 不锁定间隙。
			- 其他查询条件, 会锁定扫描到的索引范围, 通过间隙锁或临键锁来阻止其他会话在这个范围中插入值。
			- 可能的问题: InnoDB不能保证没有幻读, 需要加锁

				- 操作范围需要加间隙锁，会导致性能急剧下降
				- insert还好，update/delete where时，范围都锁住->性能下降

	- 可串行化: SERIALIZABLE

		- 对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。
		- 最严格的级别，事务串行执行，资源消耗最大；

- mysql的隔离级别

	- 可以设置全局的默认隔离级别
	- 可以单独设置会话的隔离级别
	- InnoDB实现与标准之间的差异

- 解决的问题

	- •脏读(dirty read) : 使用到从未被确认的数据(例如: 早期版本、回滚) 
	- •不可重复读: 不加锁的情况下, 其他事务update或delete会对结果集有影响 
	- •幻读(Phantom): 加锁之后, 相同的查询语句, 在不同的时间点执行时, 产生不同的 结果集

### mysql日志

- undo log

	- •保证事务的原子性 
	- •用处: 事务回滚, 一致性读、崩溃恢复。 
	- •记录事务回滚时所需的撤消操作 
	- •一条INSERT语句，对应一条DELETE的undo log 
	- •每个UPDATE语句，对应一条相反UPDATE的undo log
	- 保存位置

		- •system tablespace (MySQL 5.7默认) 放在表空间
		- •undo tablespaces (MySQL 8.0默认) 单独存放

	- 回滚段(rollback segment)

- redo log

	- 
	- •确保事务的持久性，防止事务提交后数据未刷新到磁盘就掉电或崩溃。 
	- •事务执行过程中写入 redo log,记录事务对数据页做了哪些修改。 
	- •提升性能: WAL(Write-Ahead Logging) 技术, 先写日志, 再写磁盘。 
	- •日志文件: ib_logfile0, ib_logfile1 •日志缓冲: innodb_log_buffer_size 
	- •强刷: fsync()

### MVCC多版本并发控制

- 基础

	- •使InnoDB支持一致性读: READ COMMITTED 和 REPEATABLE READ 。 
	- •让查询不被阻塞、无需等待被其他事务持有的锁，这种技术手段可以增加并发性能。 
	- •InnoDB保留被修改行的旧版本。 
	- •查询正在被其他事务更新的数据时，会读取更新之前的版本。 
	- •每行数据都存在一个版本号, 每次更新时都更新该版本 
	- •这种技术在数据库领域的使用并不普遍。 某些数据库, 以及某些MySQL存储引擎都不支持。
	- 索引的更新

		- 聚簇索引的更新 = 替换更新 
		- 二级索引的更新 = 删除+新建

- 实现机制

	- •隐藏列 

		- 

	- •事务链表， 保存还未提交的事务，事务提交则会从链表中摘除 
	- •Read view: 每个SQL一个, 包括 rw_trx_ids, low_limit_id, up_limit_id, low_limit_no等 

		- 
		- 事务提交后review view就会被删除
		- mysql不会存多个版本的数据，不过分布式数据库里有这么干的

	- •回滚段: 通过undo log动态构建旧版本数据
	- 以前可能事务里代码比较重，需要比较严格的隔离级别；现在越来越倾向于简单的事务（比如可能多数就3条sql左右），这样只需要读已提交级别的事务即可。
	- 

## 7、数据库与SQL优化

### 数据类型是否越大越好？

- 

### 存储引擎的选择

- 热数据

	- innodb

- 冷数据

	- 比如超过5年的数据
	- TokuDB

		- 

- 温数据

	- nosql

		- 如hbase

### 隐式转换

- 不会走索引

	- 

### 注意事项

- 字符集使用utf8mb4
- 注意数据类型的选择
- 设计表之前，通读DBA的指导手册
- 简单 SQL可能带来大的问题，where条件中注意数据类型，避免类型转换
- 获取行数count(*)的一些知识

	- myisam表单独存了这个数字

- CPU升高，查询越来越慢，如何定位问题并解决？

	- 定位问题的方法

		- 看应用与运维的监控

			- 
			- orzdba

		- 慢查询日志

			- 
			- 增加索引来加速慢查询

- 为何主键要单调递增？

	- 页分裂

		- 

- 为何不用UUID作为主键

	- 长度过长
	- 不递增

- 索引

	- 类型

		- Hash
		- B树/B+树

			- B树

				- 

			- B+树

				- 

	- 聚集索引和二级索引

		- 
		- 聚集索引和主键索引不是一回事

			- 聚簇索引： 把数据和索引放在一起的方式叫做聚簇索引。因为数据和索引在一起，查到了索引就查到了数据。和聚簇索引相对应的叫做非聚簇索引，也叫做二次索引，我们一般的索引都是二次索引，索引里面存放的是 主键id。需要通过主键id去二次查找。
			- 一个表只能有一个聚簇索引，并且只能建立在唯一字段上，一般都是主键列。
			- innodb  都是用聚簇索引方式来存储数据的。在有主键的时候，聚簇索引列是主键，没有主键的时候胡自动选择一个唯一字段，如果唯一字段都没有，那么会自动维护一个唯一字段作为 聚簇索引。 因为 聚簇索引直接存放数据，所以聚簇索引列比别的索引快（避免了二次查找）。所以有一种说法 叫做，innodb 里面 主键列是最快的索引 列，就是因为主键列会自动建立 聚簇索引。

	- 索引字段的选择

		- 

	- 注意索引冗余

		- 
		- 最好只建几个关键的

	- 修改表的危害

		- 索引重建

			- 如果要重建表，先删掉索引、把表建好、导入数据后，再一口气把所有索引一起重建

		- 锁表
		- 抢占资源
		- 主从延时

	- 数据量

		- 业务初期可考虑不周，字段类型使用不合理，需要变更数据类型
		- 随着业务发展，需要增加新的字段
		- 在无索引字段增加新的业务查询，需要增加索引

	- 思考题

		- 为何不用hash index？

			- 无法进行范围查询

		- 为何B+树更适合做索引？
		- 为何主键长度不能过大？

			- 影响内存中保存索引的条数

### SQL写入优化

- 大批量写入的优化

	- PreparedStatement 减少SQL解析
	- Multiple Values/Add Batch 减少交互

		- 可以加速插入，但对中间件不优化

	- Load Data，直接导入

		- 推荐数据库自带的批量导入命令来做

	- 索引和约束问题

		- 推荐做法：批量导入、导出前先删掉索引、约束，等导入结束后再重新加回来，这样效率更高
		- mysqldump就是这么干的

- 数据更新

	- 数据的范围更新

		- 尽量规避
		- 间隙锁并不是锁在操作的某个列，真正锁的是主键？这个查查，做做试验

	- 注意GAP Lock的问题
	- 导致锁范围扩大

- 模糊查询

	- like的问题

		- 只支持前缀匹配
		- 尽量用在%后面，甚至不用%
		- 数据量大，或是很多个字段都要模糊检索，走全文检索（solr/es等）
		- 少量数据，读写比很高，redis
		- 前缀匹配，否则不走索引

- 连接查询

	- 连接查询优化
	- 驱动表的选择问题
	- 避免笛卡尔积

- 索引失效

	- 索引失效情况汇总

		- NULL，not，not in，
		- 使用函数

- 减少使用or，可以用union（注意union all的区别），以及前面提到 的like
- 大数据量下，放弃所有条件组合都走索引的幻想，出门左拐"全文索引"（solr/es）
- 必要时可以使用force index来强制查询走某个索引

### 查询SQL到底怎么设计？

- 查询数据量和查询次数的平衡
- 避免不必须的大量重复数据传输
- 避免使用临时文件排序或临时表
- 分析类需求，可以用汇总表

## 8、常见场景分析

### 怎么实现主键ID

- - 自增 
- sequence 
- 模拟seq 
- UUID 
- 时间戳/随机数 
- snowflake

### 高效分页

- - 分页：count/pageSize/pageNum, 带条件的查询语句 
- 常见实现-分页插件：使用查询SQL，嵌套一个count，性能的坑？ 
- 改进一下1，重写count - 大数量级分页的问题，limit 100000,20 
- 改进一下2，反序 
- 继续改进3，技术向：带id， 
- 继续改进4，需求向：非精确分页 - 所有条件组合？ 索引？

### 乐观锁与悲观锁

- 

*XMind - Evaluation Version*

数据的CRUD，数据的持久化，我们大多数开发者平时不就是在干这个事吗？SQL的应用加上MYSQL的学习实践，更能增进SQL的理解与优化应用。