# 8分布式缓存

## 1、基础的一些概念

### 数据分类

- 按数据的使用频率和方式分类

	- 静态数据

		- 一般不变

	- 准静态数据

		- 变换频率很低

			- 部门结构设置，全国行政区划数据等

	- 中间状态数据

		- 一些计算的可服用中间数据，变量副本，配置中心的本地副本

	- 热数据

		- 使用频率高

	- 读写比较大

		- 读的频率 >> 写的频率

- 缓存

	- 广义来讲

		- 为了加速数据处理，让业务更快访问的临时存放冗余数据

	- 狭义来讲

		- 分布式系统里把缓存到内存的数据叫做内存缓存

- 缓存无处不在

	- 内存
	- CPU L1/L2/L3
	- 网络处理
	- 数据库引擎的各种buffer
	- GUI的double buffer，是一种经典的性能优化方法

### 缓存加载时机

- 启动全量加载

	- 全量加载，使用简单

- 懒加载

	- 同步使用加载

		- 较为常见
		- 先看缓存是否有数据，没有的话从数据库读取
		- 读取的数据，先放到内存，然后返回给调用方
		- 例子

			- ss第一次执行SQL时很慢：解析SQL很耗资源
			- 同样的，推荐使用PrepareStatement，也是因为可以省去解析SQL这一步，利用SQL解析缓存

	- 延迟异步加载

		- - 从缓存获取数据，不管是否为空直接返回
		- 策略1：异步）如果为空，则发起一个异步加载的线程，负责加载数据
		- 策略2：解耦）异步线程负责维护缓存的数据，定期或根据条件触发更新

			- 对于使用方完全透明

### 缓存的有效性与数据同步

- 如何评价缓存的有效性

	- 读写比
	- 命中率
	- 举例

		- 一般打到数据库中的TPS，不要超过3000-5000

- 为什么一般说变动频率大、一致性要求高的数据，不太适合用缓存?

	- 变化大，说明缓存数据与原始数据库数据一直有差异
	- 一致性要求高，意味着只能用原始数据，甚至加了事务才保险

### 缓存使用不当导致的问题

- 系统预热导致启动慢

	- 所有系统，启动都应该非常快

		- 系统奔溃时找到可用版本后可以恢复比较快

- 系统内存资源耗尽

	- 原因

		- 只加入数据，不能清理旧数据。
		- 旧数据处理不及时，或者不能有效识别无用数据。

## 2、本地缓存

### 最简单的本地缓存

- hashmap

### spring cache

- 基于注解和AOP
- 可以配置Condition和SPEL，比较灵活
- 需注意，若绕过spring则注解失效
- 核心功能

	- @Cacheable
	- @CacheEvict

		- 失效

	- @CachePut

		- 返回后加到缓存中

### guava cache

- 常见配置

	- 最大数量
	- 过期时间
	- 弱引用
	- 显式清除
	- 统计信息
	- 移除事件的监听器
	- 自动加载

### Hibernate/MyBatis缓存

- 一级缓存：session级别

	- session结束就没用了

- 二级缓存：sessionFactory级别

	- 需要显式打开
	- 全局缓存

- 一般默认使用Ehcache
- 可以手动将某些mapper中的缓存关掉

	- 

- Hinbernate有一个特殊的，查询数据缓存，缓存在实体对象这一层

	- 将某一行查询出来的Entity数据缓存，如果有更新则该缓存会自动失效

## 3、远程缓存

### 本地缓存的缺点

- 在多个集群环境同步？集群规模增大，则缓存的读写放大
- 在JVM中长期占用内存？若是堆内存，总是会影响到GC
- 缓存数据的调度处理，影响执行业务的线程，抢资源

### 分布式缓存

- Memcached
- Redis

	- REmote DIctionary Server
	- 单线程？

		- 没有阻塞就是很快

	- 推荐：redis设计与实现
	- 参考资料

		- Redis 官网：https://redis.io/ Redis 
在线测试：http://try.redis.io/ 
Redis 命令参考：http://doc.redisfans.com/

### 内存网格

- 框架

	- Hazelcast
	- Apache Ignite
	- redisson可以看做是一个弱化版的hazelcast

- 支持

	- 分布式一致性
	- 多副本
	- 缓存

- 概念

## 4、缓存策略

### 容量

- 资源有限
- 思考系统的设计容量、使用容量、峰值，应该是我们做架构设计的一个常识

### 过期策略

- 按FIFO或是LRU

	- 数据没什么特点，一般设置成LRU
	- 数据有固定特点，则可以根据特点自定义

- 按固定时间过期
- 按业务时间加权

	- 例如：3+5x

## 5、缓存常见问题

### 缓存穿透

- 现象

	- 大量并发查询不存在的KEY，导致都直接将压力透传到数据库

- 原因

	- 不存在一直为空。
	- 需要注意让缓存能够区分KEY不存在和查询到一个空值

- 解决

	- 1、缓存空值的KEY，这样第一次不存在也会被加载会记录，下次拿到有这个KEY
	- 2、Bloom过滤或RoaringBitmap 判断KEY是否存在

		- 布隆过滤器有一定误判率
		- RoaringBitmap内存占用大一些，但比较精确

	- 3、比较万能的方式：完全以缓存为准，使用延迟异步加载的策略2，这样就不会触发更新

### 缓存击穿

- 现象

	- 某个KEY失效的时候，正好有大量并发请求访问这个KEY

- 原因

	- 跟穿透类似，比较偶然

- 解决

	- 1、KEY的更新操作添加全局互斥锁。

		- 分布式锁

	- 2、比较万能的方式：完全以缓存为准，使用延迟异步加载的策略2，这样就不会触发更新

### 缓存雪崩

- 现象

	- 当某一时刻发生大规模的缓存失效的情况，会有大量的请求进来直接打到数据库，导致数据库压力过大升值宕机。

		- 比如：批处理操作不当，一下子失效所有缓存；大量并发请求进来；缓存服务器宕机

- 原因

	- 一般来说，由于更新策略、或者数据热点、缓存服务宕机等原因，可能会导致缓存数据同 一个时间点大规模不可用，或者都更新。所以，需要我们的更新策略要在时间上合适，数据要均 匀分散，缓存服务器要多台高可用

- 解决

	- 1、更新策略在时间上做到比较均匀。
	- 2、使用的热数据尽量分散到不同的机器上。
	- 3、多台机器做主从复制或者多副本，实现高可用

		- redis sentinel机制

	- 4、实现熔断限流机制，对系统进行负载能力控制

*XMind - Evaluation Version*

缓存技术，在项目中无论大小，真的是无所不在，也是十分基础，需要掌握的。